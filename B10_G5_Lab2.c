#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// WHEN YOU FINISH EACH EXERCISE, INCREMENT THIS VALUE
#define EXERCISE_NUMBER 3

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input


/* monitorInput()
*
*  Used to flag button inputs
*       - this avoids errors caused by program recognizing input, taking action, and
*         reading input again before button is released
*/
void monitorInput()
{
  if(SensorValue(button1) && !button1_pushed)
  {
    button1_pushed = true;
  }

  if(SensorValue(button2) && !button2_pushed)
  {
    button2_pushed = true;
  }
}

void exercise_1()
{
	// Define tag for enumerated type for exercise 1
	enum T_exercise1_state {
		MOTOR_STOP = 0,
		MOTOR_RUNNING = 1
	};

	// Declare variable to hold state, intialize to MOTOR_STOP state.
	T_exercise1_state exercise1_state = MOTOR_STOP;

	while(true)
	{
		// This function updates the button1_pushed and button2_pushed flags.
		monitorInput();

		// Switch the states.
		switch(exercise1_state) {

			// Code for MOTOR_STOP state:
		case MOTOR_STOP:
			// Turn motor off.
			motor[motor1] = 0;
			if ( button1_pushed ) {
				// If button1 pushed, change to the MOTOR_RUNNING state.
				exercise1_state = MOTOR_RUNNING;
				// Clear flag to indicate button 1 processed.
				button1_pushed = false;
			}
			break;
		case MOTOR_RUNNING:
			// Turn motor on.
			motor[motor1] = 50;
			if (button2_pushed) {
				// If button 2 pushed, transition to MOTOR_STOP state.
				exercise1_state = MOTOR_STOP;
				// Clear flag to indicate that button 2 processed.
				button2_pushed = false;
			}
			break;
		default:
		}

	}//end while
}

void exercise_2()
{
	enum T_test_state {
		state1 = 0,
		state2 = 1,
		//state3 = 2
	};
	/* INSERT CODE HERE
		  * - Make sure EXERCISE_NUMBER is set to 2
		  */

	T_test_state test_state = state1;

	while(true)
	{
		// This function updates the button1_pushed and button2_pushed flags.
		monitorInput();

		// Switch the states.
		switch(test_state) {

			// Code for MOTOR_STOP state:
	  	case state1:
			// Turn motor off.
			motor[motor1] = 0;

			if ( button1_pushed ) {
				// Clear flag to indicate button 2 is false when 1 is processd.
				button2_pushed = false;
				// If button1 pushed, change to the MOTOR_RUNNING state.
				test_state = state2;
				// Clear flag to indicate button 1 processed.
				button1_pushed = false;

			}

			if(button1_pushed == false)
			{
				// reset encoder upon every button press
				SensorValue[I2C_1] = 0;
			}

			break;
		case state2:
			// Turn motor on.
			motor[motor1] = 50;
			if (button2_pushed || abs(SensorValue[I2C_1]) >= 627) {
				// Clear flag to indicate button 1 is false when 2 is processd.
				button1_pushed = false;
				// If button 2 pushed, transition to MOTOR_STOP state.
			  test_state = state1;
				// Clear flag to indicate that button 2 processed.
				button2_pushed = false;
			}
			break;
		default:
		}


    }// end while



} // end exercise_2

void exercise_3()
{
	// define struct/tag for states.
	enum T_motor_states
	{
		STOPED = 0,
		FORWARD = 1,
		BACKWARD = 2
	};

	// start with motor not moving
	T_motor_states state = STOPED;

	while(true)
	{
	  monitorInput();

	   /* INSERT CODE HERE
      * - make sure EXERCISE_NUMBER is set to 3
		  */

	  switch(state)
	  {
	  	//code for motor stoped state
	  	case STOPED:
	  	// set motor to stop
	  		motor[motor1] = 0;
	  		if(button1_pushed)
	  		{
	  			// if button 1 is pressed lock button 2
					button2_pushed = false;
					// change to forward state
					state = FORWARD;
					// if button 1 is pressed lock button 1 to avoid double tap
					button1_pushed = false;
				}
				else if(button2_pushed)
	  		{
	  			// if button 2 is pressed lock button 1
					button1_pushed = false;
					// change to backward state
					state = BACKWARD;
					// if button 2 is pressed lock button 2 to avoid double tap
					button2_pushed = false;
				}
				// reset motor encoder value on every stop for reapeates
				SensorValue[I2C_1] = 0;
				writeDebugStream("STOPED\n");
	  	break;
	  	// Code for MOTOR_FORWARD state:
	  	case FORWARD:

	  		motor[motor1] = 50;
	  		// start motor in positive direction
	  		// terminate at desierd encoder value

				if(abs(SensorValue[I2C_1]) >= 3000)
				{
					button1_pushed = false;
					//set to stop state
			  	state = STOPED;
					button2_pushed = false;
			  }
			  // if the motor is still in motion and botton 2 is pressed.
				else if(SensorValue[button2])
				{
					button2_pushed = false;
					// wait until encoder reaches position before changing states.
					waitUntil(abs(SensorValue[I2C_1]) >= 3000);
					// reset sensor
				 	SensorValue[I2C_1] = 0;
				 	// move in other direction.
					state = BACKWARD;
					button1_pushed = false;
				}
				writeDebugStream("FORWARD\n");
	  	break;
	  	case BACKWARD:
	  		motor[motor1] = -50;
	  		// start motor in negative direction.

	  		// terminate at desierd encoder value.
				if (abs(SensorValue[I2C_1]) >= 3000)
				{

					button1_pushed = false;
						//set to stop state.
			  	state = STOPED;
					button2_pushed = false;
				}
				// if the motor is still in motion and botton 1 is pressed.
				else if(SensorValue[button1])
				{
					button1_pushed = false;
					// wait until encoder reaches position before changing states.
					waitUntil(abs(SensorValue[I2C_1]) >= 3000);
					// reset sensor.
				 	SensorValue[I2C_1] = 0;
				  // move in other direction.
					state = FORWARD;
					button2_pushed = false;
				}
			  writeDebugStream("BACKWARD\n");
	  	break;
	  	default:
	  		writeDebugStream("error");
	  }




  }//end while

}//end exercse_3


task main()
{
	button1_pushed = button2_pushed = false;

	switch (EXERCISE_NUMBER)
  {
     case 1:
       exercise_1();
       break;
     case 2:
       exercise_2();
       break;
     case 3:
       exercise_3();
       break;
     default: //should never get here.
   } // end switch

}// end main
