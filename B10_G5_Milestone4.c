#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPotentiometer, sensorPotentiometer)
#pragma config(Sensor, in2,    rightIR,        sensorReflection)
#pragma config(Sensor, in3,    leftIR,         sensorReflection)
#pragma config(Sensor, dgtl3,  sonarLed,       sensorDigitalOut)
#pragma config(Sensor, dgtl4,  frontSonar,     sensorSONAR_cm)
#pragma config(Sensor, dgtl6,  leftButton,     sensorTouch)
#pragma config(Sensor, dgtl7,  rightButton,    sensorTouch)
#pragma config(Sensor, I2C_1,  leftDTSensor,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  rightDTSensor,  sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port8,           rightDT,       tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port9,           leftDT,        tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port10,          arm,           tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int leftDriveTrainEncoderTarget = 0;
int rightDriveTrainEncoderTarget = 0;

//limit for motor power
const int MAX_POWER = 50;

//arm states
static const int ARM_MIN_POSITION_SENSOR_VALUE = 560;
static const int ARM_MID_POSITION_SENSOR_VALUE = 1880;
static const int ARM_MAX_POSITION_SENSOR_VALUE = 3300;

//robot task states
bool pointedAtTarget = true;
bool atTarget = false;

int threshold = 1000;
//initialize arm state to point up
int armEncoderTarget = ARM_MID_POSITION_SENSOR_VALUE;

//function to set the driveTrain state

void setDriveTrainEncoderTargets(int xDirectionTarget, int yDirectionTarget, bool zero)
{
	//zero the sensors
	if(zero)
	{
		SensorValue[leftDTSensor] = 0;
		SensorValue[rightDTSensor] = 0;
	}

	//assign motor power to respective orentations
	leftDriveTrainEncoderTarget = yDirectionTarget + xDirectionTarget;
	rightDriveTrainEncoderTarget = -(yDirectionTarget - xDirectionTarget);
}



task armController()
{
	//set the constants for the P controler
	const float KP = 0.200;

	//create error placeholder for the nessasary for the P controler
	int error;

	while (true)
	{
		//intialize error as the differance from the true value and the target
		error = armEncoderTarget - (SensorValue[armPotentiometer]);
		//assign power to the motor by KP * error
		motor[arm] = KP * error;
		wait1Msec(10);
	}
}

task leftDriveTrainEncPIDControl()
{
	/*const float KP = 0.085;
	const float KI = 0.0001;
	const float KD = 0.030;*/

	//set the constants for the PID controler
	const float KP = 1.80;
	const float KI = 0.15;
	const float KD = 2.85;



	// set the integral limit to prevent an integral wind up
	const float INTEGRAL_LIMIT = 20.0 / KI;

	//create variables for the nessasary for the PID controler
	int error;
	int errorPrevious;
	int integral;
	int derivative;
	int power;

	while (true)
	{
		//intialize error as the differance from the true value and the target
		error = leftDriveTrainEncoderTarget - (SensorValue[leftDTSensor]);
		//calculate the real time integral as an increment of the slices of error under the the SensorValue vs time curve
		integral += error;

		//calculate the real time derivitive by calculating the difference between the error and previos error
		derivative = error - errorPrevious;

		//To prevent integral wind up limmit how big the intgral can get
		if(abs(integral) > INTEGRAL_LIMIT)
		{
			integral = sgn(integral) * INTEGRAL_LIMIT;
		}

		//assign the respective gains
		int pGain = KP * error;
		int iGain = KI * integral;
		int dGain = KD * derivative;

		// add all the gains to make the power
		power = pGain + dGain + iGain; //+ iGain + dGain;
		//writeDebugStream("%-5d %-5d\n" , dGain, power);

		//limit the power to avoid skid
		if(abs(power) > MAX_POWER)
		{
			power = sgn(power) * MAX_POWER;
		}
		//assign power to the motor
		motor[leftDT] = power;

		//save the previous error for next loop
		errorPrevious = error;

		wait1Msec(10);
	}
}

task rightDriveTrainEncPIDControl()
{
	/*const float KP = 0.085;
	const float KI = 0.0001;
	const float KD = 0.030;*/

	//set the constants for the PID controler
	const float KP = 1.80;
	const float KI = 0.15;
	const float KD = 2.85;



	// set the integral limit to prevent an integral wind up
	const float INTEGRAL_LIMIT = 20.0 / KI;

	//create variables for the nessasary for the PID
	int error;
	int errorPrevious;
	int integral;
	int derivative;
	int power;


	while (true)
	{
		//intialize error as the differance from the true value and the target
		error = (rightDriveTrainEncoderTarget) - (SensorValue[rightDTSensor]);

		//calculate the real time integral as an increment of the slices of error under the the SensorValue vs time curve
		integral += error;

		//calculate the real time derivitive by calculating the difference between the error and previos error
		derivative = error - errorPrevious;

		//To prevent integral wind up limmit how big the intgral can get
		if(abs(integral) > INTEGRAL_LIMIT)
		{
			integral = sgn(integral) * INTEGRAL_LIMIT;
		}

		//assign the respective gains
		int pGain = KP * error;
		int iGain = KI * integral;
		int dGain = KD * derivative;

		// add all the gains to make the power
		power = pGain + dGain + iGain; //+ iGain + dGain;
		//writeDebugStream("%-5d %-5d\n" , dGain, power);

		//limit the power to avoid skid
		if(abs(power) > MAX_POWER)
		{
			power = sgn(power) * MAX_POWER;
		}
		//assign power to the motor
		motor[rightDT] = power;
		//save the previous error for next loop
		errorPrevious = error;
		//writeDebugStream("%-5d %-5d %-5d \n" ,time1[T1], SensorValue[leftDTSensor],  SensorValue[rightDTSensor]);
		wait1Msec(10);
	}
}

//sets the robot to turn left at start
bool lastReadRight = false;
bool lastReadLeft = true;

task lastRead()
{
	while(true)
	{		//if the robot sees the sensor the sonsor only on the left side then it will turn to the left to make the right see as well
		if(threshold > SensorValue[leftIR])
		{
			lastReadRight = false;
			lastReadLeft = true;
		}
		//if the robot sees the sensor the sonsor only on the right side then it will turn to the right to make the left see as well
		if(threshold > SensorValue[rightIR])
		{
			lastReadRight = true;
			lastReadLeft = false;
		}

		wait1Msec(10);
	}
}

task targetCheck()
{
	while(true)
	{
		//if the beacon is in front of the robot turn on light
		if(SensorValue[frontSonar] < 8 && SensorValue[frontSonar] != -1)
		{
			//indicate it is at the target
			atTarget = true;
			//turn on LED
			SensorValue[sonarLed] = 1;
		}
		else
		{
			//indicate it is not at the target
			atTarget = false;
			//turn off LED
			SensorValue[sonarLed] = 0;
		}
		wait1Msec(10);
	}
}

task trackSource()
{
	//set the intal rotation to 0
	int rotation = 0;
	//set the rotation step
	int delta = 1;


	//int counter = 0;
	int rightIRSen = 0;
	int leftIRSen = 0;

	while(true)
	{
		//reset rotation upon every search

		rotation = 0;
		while(!pointedAtTarget)
		{

			//check if the robot is looking or at the target
			leftIRSen = SensorValue[leftIR];
			rightIRSen = SensorValue[rightIR];
			if((threshold > (leftIRSen) && threshold > (rightIRSen)) || atTarget)
			{

				//stop rotating

				setDriveTrainEncoderTargets(0 ,0, true);

				// declare the robot is pointed at the target
				pointedAtTarget = true;
			}
			else
			{
				//this turns the robot the direction that the beacon is lost
				if(lastReadRight)
				{

					delta = abs(delta);

				}
				else if(lastReadLeft)
				{

					delta = -abs(delta);


				}
				//increment rotation
				rotation += delta;
				setDriveTrainEncoderTargets(rotation, 0, false);
			}
			wait1Msec(5);
		}
		wait1Msec(10);
	}

}




task main()
{
	//start tasks ready for project

	//task to start right drivetrain PID
	startTask(rightDriveTrainEncPIDControl);
	//task to start left drivetrain PID
	startTask(leftDriveTrainEncPIDControl);

	//task to see if the target is in conecttion proximity
	startTask(targetCheck);
	//task to pick the rotating directions
	startTask(lastRead);
	//task for arm P controler
	startTask(armController);
	//task to point at source
	startTask(trackSource);

	while(true)
	{
		//if right button is pressed perform long distance beacon atachment

		if(SensorValue[rightButton])
		{
			//set far distance threshold
			threshold = 3600;
			//start the search protical
			pointedAtTarget = false;
			//wait until it points at the target
			waitUntil(pointedAtTarget || atTarget);
			//move robot with step 3500
			setDriveTrainEncoderTargets(0, 3500, true);
			//wait until it finishes traveling or at the target
			waitUntil(SensorValue[leftDTSensor] > 3490 || atTarget);
			//stop the robot
			setDriveTrainEncoderTargets(0,0,true);
			//set mid distance threshold
			threshold = 2500;
			//start the search protical
			pointedAtTarget = false;
			//wait until it points at the target
			waitUntil(pointedAtTarget || atTarget);
			//move robot with step 1000
			setDriveTrainEncoderTargets(0, 1000, true);
			//wait until it finishes traveling or at the target
			waitUntil(SensorValue[leftDTSensor] > 990 || atTarget);
			//stop the robot
			setDriveTrainEncoderTargets(0,0,true);
			//set short distance threshold
			threshold = 2300;

			//do untill it is at the target
			while(!atTarget)
			{
				//start the search protical
				pointedAtTarget = false;
				//wait until it points at the target
				waitUntil(pointedAtTarget || atTarget);
				//move robot with step 100
				setDriveTrainEncoderTargets(0, 100, true);
				//wait until it finishes traveling or at the target
				waitUntil(SensorValue[leftDTSensor] > 90 || atTarget);
				//stop the robot
				setDriveTrainEncoderTargets(0,0,true);

			}

			//move arm to max position to attach cable
			armEncoderTarget = ARM_MAX_POSITION_SENSOR_VALUE;
			//waitUntil it sucessfully attaches
			waitUntil(SensorValue[armPotentiometer] > 3250);
			wait1Msec(250);
			//move arm back to not touch the cable
			armEncoderTarget = ARM_MIN_POSITION_SENSOR_VALUE;
			waitUntil(SensorValue[armPotentiometer] < 700);
			wait1Msec(250);
			//back up robot
			setDriveTrainEncoderTargets(0,-400,true);
		}
		//if right button is pressed perform long distance beacon atachment
		if(SensorValue[leftButton])
		{
			//set short distance threshold
			threshold = 2300;

			//do untill it is at the target
			while(!atTarget)
			{
				//start the search protical
				pointedAtTarget = false;
				//wait until it points at the target
				waitUntil(pointedAtTarget || atTarget);
				//move robot with step 100
				setDriveTrainEncoderTargets(0, 100, true);
				//wait until it finishes traveling or at the target
				waitUntil(SensorValue[leftDTSensor] > 90 || atTarget);
				//stop the robot
				setDriveTrainEncoderTargets(0,0,true);

			}

			//move arm to max position to attach cable
			armEncoderTarget = ARM_MAX_POSITION_SENSOR_VALUE;
			//waitUntil it sucessfully attaches
			waitUntil(SensorValue[armPotentiometer] > 3250);
			wait1Msec(250);
			//move arm back to not touch the cable
			armEncoderTarget = ARM_MIN_POSITION_SENSOR_VALUE;
			waitUntil(SensorValue[armPotentiometer] < 700);
			wait1Msec(250);
			//back up robot
			setDriveTrainEncoderTargets(0,-400,true);
		}

		wait1Msec(10);
	}
}
